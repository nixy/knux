#!/usr/bin/env bash

set -f

proffproc_match_command()
{
    local readonly cmd="$1"
    local readonly cmds="$2"

    for valid_cmd in $cmds; do
        if [ "$cmd" = "$valid_cmd" ]; then
            return 0
        fi
    done
    return 1
}

#TODO: Figure out whitesace stripping
proffproc_execute()
{
    echo "called: proffproc_execute $@"
    local readonly cmd="$1"

    echo "---------------------------------"
    echo "\$cmd is '$cmd'"
    echo "\$args are '${args% }'"

    if [ "$cmd" ]; then
        if [ "${args% }" ]; then
            $cmd "${args% }"
        else
            $cmd
        fi
    else
        echo "execute: error: no \$cmd"
    fi
}

#TODO: Figure out tail word splitting
#TODO: Figure out args word splitting
proffproc()
{
    echo "called: proffproc $@"
    local readonly cmd="$1"
    local readonly cmds="$2"; shift 2
    local readonly head="$1"; shift
    # "$@" is the tail

    echo "---------------------------------"
    echo "\$cmd is '$cmd'"
    echo "\$cmds is '$cmds'"
    echo "\$head is '$head'"
    echo "\$args is '$args'"

    if [ "$#" -gt 0 ]; then
        if [ -n "$cmd" ]; then
            args+="$head " proffproc "$cmd" "$cmds" "$@"
            unset args; return 0
        else
            if proffproc_match_command "$head" "$cmds"; then
                proffproc "$head" "$cmds" "$@"
            unset args; return 0
            else
                args+="$head " proffproc "$cmd" "$cmds" "$@"
            unset args; return 0
            fi
        fi
    else
        if [ -n "$head" ]; then
            args+="$head " proffproc "$cmd" "$cmds" "$@"
            unset args; return 0
        else
            proffproc_execute "$cmd"
        fi
    fi
}

proffproc "" "ls echo" echo "Home, sweet" "home"
#proffproc_match_command "echo" "ls echo"
